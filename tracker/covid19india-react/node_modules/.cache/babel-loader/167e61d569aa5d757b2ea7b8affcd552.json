{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.d3 = global.d3 || {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n  /**\n   * de Casteljau's algorithm for drawing and splitting bezier curves.\n   * Inspired by https://pomax.github.io/bezierinfo/\n   *\n   * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n   *   The original segment to split.\n   * @param {Number} t Where to split the curve (value between [0, 1])\n   * @return {Object} An object { left, right } where left is the segment from 0..t and\n   *   right is the segment from t..1.\n   */\n\n\n  function decasteljau(points, t) {\n    var left = [];\n    var right = [];\n\n    function decasteljauRecurse(points, t) {\n      if (points.length === 1) {\n        left.push(points[0]);\n        right.push(points[0]);\n      } else {\n        var newPoints = Array(points.length - 1);\n\n        for (var i = 0; i < newPoints.length; i++) {\n          if (i === 0) {\n            left.push(points[0]);\n          }\n\n          if (i === newPoints.length - 1) {\n            right.push(points[i + 1]);\n          }\n\n          newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n        }\n\n        decasteljauRecurse(newPoints, t);\n      }\n    }\n\n    if (points.length) {\n      decasteljauRecurse(points, t);\n    }\n\n    return {\n      left: left,\n      right: right.reverse()\n    };\n  }\n  /**\n   * Convert segments represented as points back into a command object\n   *\n   * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n   *   Represents a segment\n   * @return {Object} A command object representing the segment.\n   */\n\n\n  function pointsToCommand(points) {\n    var command = {};\n\n    if (points.length === 4) {\n      command.x2 = points[2][0];\n      command.y2 = points[2][1];\n    }\n\n    if (points.length >= 3) {\n      command.x1 = points[1][0];\n      command.y1 = points[1][1];\n    }\n\n    command.x = points[points.length - 1][0];\n    command.y = points[points.length - 1][1];\n\n    if (points.length === 4) {\n      // start, control1, control2, end\n      command.type = 'C';\n    } else if (points.length === 3) {\n      // start, control, end\n      command.type = 'Q';\n    } else {\n      // start, end\n      command.type = 'L';\n    }\n\n    return command;\n  }\n  /**\n   * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n   *\n   * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n   * @param {Number} segmentCount Number of segments to split the original into\n   * @return {Number[][][]} Array of segments\n   */\n\n\n  function splitCurveAsPoints(points, segmentCount) {\n    segmentCount = segmentCount || 2;\n    var segments = [];\n    var remainingCurve = points;\n    var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n    // t=  0.33   0.66   1\n    // x-----o-----------x\n    // r=  0.33\n    //       x-----o-----x\n    // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n    // x-----x-----x-----x----x\n    // t=  0.25   0.5   0.75  1\n    // x-----o----------------x\n    // r=  0.25\n    //       x-----o----------x\n    // r=         0.33  (0.25 / (1 - 0.25))\n    //             x-----o----x\n    // r=         0.5  (0.25 / (1 - 0.5))\n\n    for (var i = 0; i < segmentCount - 1; i++) {\n      var tRelative = tIncrement / (1 - tIncrement * i);\n      var split = decasteljau(remainingCurve, tRelative);\n      segments.push(split.left);\n      remainingCurve = split.right;\n    } // last segment is just to the end from the last point\n\n\n    segments.push(remainingCurve);\n    return segments;\n  }\n  /**\n   * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n   * to split into to the desired number of segments.\n   *\n   * @param {Object} commandStart The start command object\n   * @param {Object} commandEnd The end command object\n   * @param {Number} segmentCount The number of segments to create\n   * @return {Object[]} An array of commands representing the segments in sequence\n   */\n\n\n  function splitCurve(commandStart, commandEnd, segmentCount) {\n    var points = [[commandStart.x, commandStart.y]];\n\n    if (commandEnd.x1 != null) {\n      points.push([commandEnd.x1, commandEnd.y1]);\n    }\n\n    if (commandEnd.x2 != null) {\n      points.push([commandEnd.x2, commandEnd.y2]);\n    }\n\n    points.push([commandEnd.x, commandEnd.y]);\n    return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n  }\n\n  var commandTokenRegex = /[MLCSTQAHVmlcstqahv]|-?[\\d.e+-]+/g;\n  /**\n   * List of params for each command type in a path `d` attribute\n   */\n\n  var typeMap = {\n    M: ['x', 'y'],\n    L: ['x', 'y'],\n    H: ['x'],\n    V: ['y'],\n    C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n    S: ['x2', 'y2', 'x', 'y'],\n    Q: ['x1', 'y1', 'x', 'y'],\n    T: ['x', 'y'],\n    A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y']\n  }; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\n  Object.keys(typeMap).forEach(function (key) {\n    typeMap[key.toLowerCase()] = typeMap[key];\n  });\n\n  function arrayOfLength(length, value) {\n    var array = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      array[i] = value;\n    }\n\n    return array;\n  }\n  /**\n   * Converts a command object to a string to be used in a `d` attribute\n   * @param {Object} command A command object\n   * @return {String} The string for the `d` attribute\n   */\n\n\n  function commandToString(command) {\n    return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n      return command[p];\n    }).join(','));\n  }\n  /**\n   * Converts command A to have the same type as command B.\n   *\n   * e.g., L0,5 -> C0,5,0,5,0,5\n   *\n   * Uses these rules:\n   * x1 <- x\n   * x2 <- x\n   * y1 <- y\n   * y2 <- y\n   * rx <- 0\n   * ry <- 0\n   * xAxisRotation <- read from B\n   * largeArcFlag <- read from B\n   * sweepflag <- read from B\n   *\n   * @param {Object} aCommand Command object from path `d` attribute\n   * @param {Object} bCommand Command object from path `d` attribute to match against\n   * @return {Object} aCommand converted to type of bCommand\n   */\n\n\n  function convertToSameType(aCommand, bCommand) {\n    var conversionMap = {\n      x1: 'x',\n      y1: 'y',\n      x2: 'x',\n      y2: 'y'\n    };\n    var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n    if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n      var aConverted = {};\n      Object.keys(bCommand).forEach(function (bKey) {\n        var bValue = bCommand[bKey]; // first read from the A command\n\n        var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n        if (aValue === undefined) {\n          if (readFromBKeys.includes(bKey)) {\n            aValue = bValue;\n          } else {\n            // if it wasn't in the A command, see if an equivalent was\n            if (aValue === undefined && conversionMap[bKey]) {\n              aValue = aCommand[conversionMap[bKey]];\n            } // if it doesn't have a converted value, use 0\n\n\n            if (aValue === undefined) {\n              aValue = 0;\n            }\n          }\n        }\n\n        aConverted[bKey] = aValue;\n      }); // update the type to match B\n\n      aConverted.type = bCommand.type;\n      aCommand = aConverted;\n    }\n\n    return aCommand;\n  }\n  /**\n   * Interpolate between command objects commandStart and commandEnd segmentCount times.\n   * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n   * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n   *\n   * @param {Object} commandStart Command object at the beginning of the segment\n   * @param {Object} commandEnd Command object at the end of the segment\n   * @param {Number} segmentCount The number of segments to split this into. If only 1\n   *   Then [commandEnd] is returned.\n   * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n   *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n   */\n\n\n  function splitSegment(commandStart, commandEnd, segmentCount) {\n    var segments = []; // line, quadratic bezier, or cubic bezier\n\n    if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n      segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n    } else {\n      var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n      if (copyCommand.type === 'M') {\n        copyCommand.type = 'L';\n      }\n\n      segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n        return copyCommand;\n      }));\n      segments.push(commandEnd);\n    }\n\n    return segments;\n  }\n  /**\n   * Extends an array of commandsToExtend to the length of the referenceCommands by\n   * splitting segments until the number of commands match. Ensures all the actual\n   * points of commandsToExtend are in the extended array.\n   *\n   * @param {Object[]} commandsToExtend The command object array to extend\n   * @param {Object[]} referenceCommands The command object array to match in length\n   * @param {Function} excludeSegment a function that takes a start command object and\n   *   end command object and returns true if the segment should be excluded from splitting.\n   * @return {Object[]} The extended commandsToExtend array\n   */\n\n\n  function extend(commandsToExtend, referenceCommands, excludeSegment) {\n    // compute insertion points:\n    // number of segments in the path to extend\n    var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n    var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n    var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n    // should be added in that segment (should always be >= 1 since we need each\n    // point itself).\n    // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n    var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n      var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n      if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n        // set the insertIndex to the segment that this point should be added to:\n        // round the insertIndex essentially so we split half and half on\n        // neighbouring segments. hence the segmentRatio * i < 0.5\n        var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n        if (accum[insertIndex]) {\n          // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n          // but if two adjacent segments are supposed to be skipped, this will not perform as\n          // expected. Could be updated to search for nearest segment to place the point in, but\n          // will only do that if necessary.\n          // add to the prior segment\n          if (addToPriorSegment) {\n            if (insertIndex > 0) {\n              insertIndex -= 1; // not possible to add to previous so adding to next\n            } else if (insertIndex < commandsToExtend.length - 1) {\n              insertIndex += 1;\n            } // add to next segment\n\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1; // not possible to add to next so adding to previous\n          } else if (insertIndex > 0) {\n            insertIndex -= 1;\n          }\n        }\n      }\n\n      accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n      return accum;\n    }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n    var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n      // if last command, just add `segmentCount` number of times\n      if (i === commandsToExtend.length - 1) {\n        var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n        if (lastCommandCopies[0].type === 'M') {\n          lastCommandCopies.forEach(function (d) {\n            d.type = 'L';\n          });\n        }\n\n        return extended.concat(lastCommandCopies);\n      } // otherwise, split the segment segmentCount times.\n\n\n      return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n    }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n    extended.unshift(commandsToExtend[0]);\n    return extended;\n  }\n  /**\n   * Takes a path `d` string and converts it into an array of command\n   * objects. Drops the `Z` character.\n   *\n   * @param {String|null} d A path `d` string\n   */\n\n\n  function makeCommands(d) {\n    // split into valid tokens\n    var tokens = (d || '').match(commandTokenRegex) || [];\n    var commands = [];\n    var commandArgs;\n    var command; // iterate over each token, checking if we are at a new command\n    // by presence in the typeMap\n\n    for (var i = 0; i < tokens.length; ++i) {\n      commandArgs = typeMap[tokens[i]]; // new command found:\n\n      if (commandArgs) {\n        command = {\n          type: tokens[i]\n        }; // add each of the expected args for this command:\n\n        for (var a = 0; a < commandArgs.length; ++a) {\n          command[commandArgs[a]] = +tokens[i + a + 1];\n        } // need to increment our token index appropriately since\n        // we consumed token args\n\n\n        i += commandArgs.length;\n        commands.push(command);\n      }\n    }\n\n    return commands;\n  }\n  /**\n   * Interpolate from A to B by extending A and B during interpolation to have\n   * the same number of points. This allows for a smooth transition when they\n   * have a different number of points.\n   *\n   * Ignores the `Z` character in paths unless both A and B end with it.\n   *\n   * @param {String} a The `d` attribute for a path\n   * @param {String} b The `d` attribute for a path\n   * @param {Function} excludeSegment a function that takes a start command object and\n   *   end command object and returns true if the segment should be excluded from splitting.\n   * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n   */\n\n\n  function interpolatePath(a, b, excludeSegment) {\n    var aCommands = makeCommands(a);\n    var bCommands = makeCommands(b);\n\n    if (!aCommands.length && !bCommands.length) {\n      return function nullInterpolator() {\n        return '';\n      };\n    } // if A is empty, treat it as if it used to contain just the first point\n    // of B. This makes it so the line extends out of from that first point.\n\n\n    if (!aCommands.length) {\n      aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n      // of A. This makes it so the line retracts into the first point.\n    } else if (!bCommands.length) {\n      bCommands.push(aCommands[0]);\n    } // extend to match equal size\n\n\n    var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n    if (numPointsToExtend !== 0) {\n      // B has more points than A, so add points to A before interpolating\n      if (bCommands.length > aCommands.length) {\n        aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n      } else if (bCommands.length < aCommands.length) {\n        bCommands = extend(bCommands, aCommands, excludeSegment);\n      }\n    } // commands have same length now.\n    // convert commands in A to the same type as those in B\n\n\n    aCommands = aCommands.map(function (aCommand, i) {\n      return convertToSameType(aCommand, bCommands[i]);\n    }); // create mutable interpolated command objects\n\n    var interpolatedCommands = aCommands.map(function (aCommand) {\n      return _objectSpread2({}, aCommand);\n    });\n    var addZ = (a == null || a[a.length - 1] === 'Z') && (b == null || b[b.length - 1] === 'Z');\n    return function pathInterpolator(t) {\n      // at 1 return the final value without the extensions used during interpolation\n      if (t === 1) {\n        return b == null ? '' : b;\n      } // interpolate the commands using the mutable interpolated command objs\n      // we can skip at t=0 since we copied aCommands to begin\n\n\n      if (t > 0) {\n        for (var i = 0; i < interpolatedCommands.length; ++i) {\n          var aCommand = aCommands[i];\n          var bCommand = bCommands[i];\n          var interpolatedCommand = interpolatedCommands[i];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = typeMap[interpolatedCommand.type][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var arg = _step.value;\n              interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n              if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n                interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      } // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n\n      var interpolatedString = '';\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = interpolatedCommands[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _interpolatedCommand = _step2.value;\n          interpolatedString += commandToString(_interpolatedCommand);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (addZ) {\n        interpolatedString += 'Z';\n      }\n\n      return interpolatedString;\n    };\n  }\n\n  exports.interpolatePath = interpolatePath;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/home/ubuntu/myprojectdir/tracker/covid19india-react/node_modules/d3-interpolate-path/build/d3-interpolate-path.js"],"names":["global","factory","exports","module","define","amd","self","d3","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","forEach","getOwnPropertyDescriptors","defineProperties","decasteljau","points","t","left","right","decasteljauRecurse","newPoints","Array","reverse","pointsToCommand","command","x2","y2","x1","y1","x","y","type","splitCurveAsPoints","segmentCount","segments","remainingCurve","tIncrement","tRelative","split","splitCurve","commandStart","commandEnd","map","commandTokenRegex","typeMap","M","L","H","V","C","S","Q","T","A","toLowerCase","arrayOfLength","array","commandToString","concat","p","join","convertToSameType","aCommand","bCommand","conversionMap","readFromBKeys","toUpperCase","aConverted","bKey","bValue","aValue","undefined","includes","splitSegment","copyCommand","extend","commandsToExtend","referenceCommands","excludeSegment","numSegmentsToExtend","numReferenceSegments","segmentRatio","countPointsPerSegment","reduce","accum","d","insertIndex","Math","floor","addToPriorSegment","extended","lastCommandCopies","unshift","makeCommands","tokens","match","commands","commandArgs","a","interpolatePath","b","aCommands","bCommands","nullInterpolator","numPointsToExtend","abs","interpolatedCommands","addZ","pathInterpolator","interpolatedCommand","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","next","done","arg","round","err","interpolatedString","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_interpolatedCommand"],"mappings":"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","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\ntypeof define === 'function' && define.amd ? define(['exports'], factory) :\n(global = global || self, factory(global.d3 = global.d3 || {}));\n}(this, (function (exports) { 'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\nfunction decasteljau(points, t) {\n  var left = [];\n  var right = [];\n\n  function decasteljauRecurse(points, t) {\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      var newPoints = Array(points.length - 1);\n\n      for (var i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return {\n    left: left,\n    right: right.reverse()\n  };\n}\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\n\n\nfunction pointsToCommand(points) {\n  var command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\n\n\nfunction splitCurveAsPoints(points, segmentCount) {\n  segmentCount = segmentCount || 2;\n  var segments = [];\n  var remainingCurve = points;\n  var tIncrement = 1 / segmentCount; // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (var i = 0; i < segmentCount - 1; i++) {\n    var tRelative = tIncrement / (1 - tIncrement * i);\n    var split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  } // last segment is just to the end from the last point\n\n\n  segments.push(remainingCurve);\n  return segments;\n}\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\n\n\nfunction splitCurve(commandStart, commandEnd, segmentCount) {\n  var points = [[commandStart.x, commandStart.y]];\n\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n\n  points.push([commandEnd.x, commandEnd.y]);\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\nvar commandTokenRegex = /[MLCSTQAHVmlcstqahv]|-?[\\d.e+-]+/g;\n/**\n * List of params for each command type in a path `d` attribute\n */\n\nvar typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y']\n}; // Add lower case entries too matching uppercase (e.g. 'm' == 'M')\n\nObject.keys(typeMap).forEach(function (key) {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  var array = Array(length);\n\n  for (var i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\n\n\nfunction commandToString(command) {\n  return \"\".concat(command.type).concat(typeMap[command.type].map(function (p) {\n    return command[p];\n  }).join(','));\n}\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\n\n\nfunction convertToSameType(aCommand, bCommand) {\n  var conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y'\n  };\n  var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag']; // convert (but ignore M types)\n\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    var aConverted = {};\n    Object.keys(bCommand).forEach(function (bKey) {\n      var bValue = bCommand[bKey]; // first read from the A command\n\n      var aValue = aCommand[bKey]; // if it is one of these values, read from B no matter what\n\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          } // if it doesn't have a converted value, use 0\n\n\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    }); // update the type to match B\n\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\n\n\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  var segments = []; // line, quadratic bezier, or cubic bezier\n\n  if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount)); // general case - just copy the same point\n  } else {\n    var copyCommand = _extends({}, commandStart); // convert M to L\n\n\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n      return copyCommand;\n    }));\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\n\n\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  // compute insertion points:\n  // number of segments in the path to extend\n  var numSegmentsToExtend = commandsToExtend.length - 1; // number of segments in the reference path.\n\n  var numReferenceSegments = referenceCommands.length - 1; // this value is always between [0, 1].\n\n  var segmentRatio = numSegmentsToExtend / numReferenceSegments; // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n\n  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n    var insertIndex = Math.floor(segmentRatio * i); // handle excluding segments\n\n    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n      // set the insertIndex to the segment that this point should be added to:\n      // round the insertIndex essentially so we split half and half on\n      // neighbouring segments. hence the segmentRatio * i < 0.5\n      var addToPriorSegment = segmentRatio * i % 1 < 0.5; // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n\n      if (accum[insertIndex]) {\n        // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n        // but if two adjacent segments are supposed to be skipped, this will not perform as\n        // expected. Could be updated to search for nearest segment to place the point in, but\n        // will only do that if necessary.\n        // add to the prior segment\n        if (addToPriorSegment) {\n          if (insertIndex > 0) {\n            insertIndex -= 1; // not possible to add to previous so adding to next\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n          } // add to next segment\n\n        } else if (insertIndex < commandsToExtend.length - 1) {\n          insertIndex += 1; // not possible to add to next so adding to previous\n        } else if (insertIndex > 0) {\n          insertIndex -= 1;\n        }\n      }\n    }\n\n    accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n    return accum;\n  }, []); // extend each segment to have the correct number of points for a smooth interpolation\n\n  var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1])); // convert M to L\n\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach(function (d) {\n          d.type = 'L';\n        });\n      }\n\n      return extended.concat(lastCommandCopies);\n    } // otherwise, split the segment segmentCount times.\n\n\n    return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n  }, []); // add in the very first point since splitSegment only adds in the ones after it\n\n  extended.unshift(commandsToExtend[0]);\n  return extended;\n}\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\n\n\nfunction makeCommands(d) {\n  // split into valid tokens\n  var tokens = (d || '').match(commandTokenRegex) || [];\n  var commands = [];\n  var commandArgs;\n  var command; // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n\n  for (var i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]]; // new command found:\n\n    if (commandArgs) {\n      command = {\n        type: tokens[i]\n      }; // add each of the expected args for this command:\n\n      for (var a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      } // need to increment our token index appropriately since\n      // we consumed token args\n\n\n      i += commandArgs.length;\n      commands.push(command);\n    }\n  }\n\n  return commands;\n}\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\n\n\nfunction interpolatePath(a, b, excludeSegment) {\n  var aCommands = makeCommands(a);\n  var bCommands = makeCommands(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      return '';\n    };\n  } // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n\n\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]); // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  } // extend to match equal size\n\n\n  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment); // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  } // commands have same length now.\n  // convert commands in A to the same type as those in B\n\n\n  aCommands = aCommands.map(function (aCommand, i) {\n    return convertToSameType(aCommand, bCommands[i]);\n  }); // create mutable interpolated command objects\n\n  var interpolatedCommands = aCommands.map(function (aCommand) {\n    return _objectSpread2({}, aCommand);\n  });\n  var addZ = (a == null || a[a.length - 1] === 'Z') && (b == null || b[b.length - 1] === 'Z');\n  return function pathInterpolator(t) {\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    } // interpolate the commands using the mutable interpolated command objs\n    // we can skip at t=0 since we copied aCommands to begin\n\n\n    if (t > 0) {\n      for (var i = 0; i < interpolatedCommands.length; ++i) {\n        var aCommand = aCommands[i];\n        var bCommand = bCommands[i];\n        var interpolatedCommand = interpolatedCommands[i];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = typeMap[interpolatedCommand.type][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var arg = _step.value;\n            interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg]; // do not use floats for flags (#27), round to integer\n\n            if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n              interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n    } // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n\n\n    var interpolatedString = '';\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = interpolatedCommands[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _interpolatedCommand = _step2.value;\n        interpolatedString += commandToString(_interpolatedCommand);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (addZ) {\n      interpolatedString += 'Z';\n    }\n\n    return interpolatedString;\n  };\n}\n\nexports.interpolatePath = interpolatePath;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}